# Elasticsearch 인덱스 설계 (Index Design)

Elasticsearch에서 효율적인 인덱스 설계는 검색 성능, 확장성 및 데이터 관리에 큰 영향을 미칩니다. 이 문서에서는 효과적인 인덱스 설계 전략과 모범 사례에 대해 설명합니다.

## 1. 인덱스 설계 기본 원칙

### 1.1 인덱스 설계 시 고려사항

효과적인 인덱스 설계를 위해 다음 사항을 고려해야 합니다:

- **데이터 특성**: 데이터의 양, 수집 속도, 보존 기간
- **쿼리 패턴**: 검색, 집계, 필터링 방식
- **성능 요구사항**: 지연 시간, 처리량, 리소스 사용량
- **운영 관리**: 백업, 업데이트, 마이그레이션 용이성

### 1.2 인덱스 세분화 vs 통합

#### 하나의 큰 인덱스
- **장점**: 설정 간소화, 샤드 오버헤드 감소, 조인 필요 없음
- **단점**: 확장성 제한, 수명 주기 관리 복잡, 모든 필드가 모든 문서에 적용

#### 여러 개의 작은 인덱스
- **장점**: 유연한 관리, 개별 최적화, 수명 주기 관리 용이
- **단점**: 관리 복잡성 증가, 크로스 인덱스 검색 필요, 인덱스 오버헤드 증가

## 2. 시간 기반 인덱스 전략

### 2.1 시간 기반 인덱스 개요

시간 기반 인덱스는 데이터를 시간 간격(일별, 주별, 월별)으로 분할합니다. 이는 로그, 이벤트, 메트릭 데이터에 특히 적합합니다.

```
logs-2023.04.01
logs-2023.04.02
logs-2023.04.03
...
```

### 2.2 시간 기반 인덱스의 장점

- **효율적인 데이터 수명 주기 관리**: 오래된 데이터를 쉽게 삭제하거나 아카이브
- **검색 성능 향상**: 시간 범위 검색이 관련 인덱스만 대상으로 수행
- **롤링 업데이트 용이**: 매핑 변경 시 새 인덱스에만 적용 가능
- **샤드 크기 최적화**: 균일한 데이터 분포 유지

### 2.3 인덱스 라이프사이클 관리 (ILM)

ILM을 사용하여 인덱스 수명 주기를 자동화할 수 있습니다:

```json
PUT _ilm/policy/logs_policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50GB",
            "max_age": "1d"
          }
        }
      },
      "warm": {
        "min_age": "2d",
        "actions": {
          "shrink": {
            "number_of_shards": 1
          },
          "forcemerge": {
            "max_num_segments": 1
          }
        }
      },
      "cold": {
        "min_age": "30d",
        "actions": {
          "freeze": {}
        }
      },
      "delete": {
        "min_age": "90d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
```

## 3. 샤딩 전략

### 3.1 샤드 개수 결정

샤드는 분산 검색과 확장성의 기본 단위이지만, 너무 많은 샤드는 오버헤드를 발생시킵니다.

#### 샤드 수 결정 요소:
- **데이터 볼륨**: 샤드당 20GB~40GB 권장
- **노드 수**: 노드당 샤드 수 고려 (너무 많은 샤드는 오버헤드 증가)
- **쿼리 복잡성**: 복잡한 집계는 더 많은 리소스 필요
- **확장 계획**: 미래 성장을 고려한 여유 공간

### 3.2 샤딩 모범 사례

- **너무 많은 샤드 피하기**: 노드당 샤드 수를 제한 (일반적으로 20개 이하)
- **불균형 피하기**: 라우팅 키를 사용하여 균일한 분포 유지
- **핫스팟 방지**: 시간 기반 데이터의 경우 롤오버 정책 사용
- **재샤딩 계획**: 필요 시 리인덱싱 또는 분할 API 활용

```json
# 인덱스 생성 시 샤드 수 지정
PUT /my_index
{
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  }
}
```

### 3.3 라우팅 전략

커스텀 라우팅을 사용하여 관련 데이터를 동일한 샤드에 배치할 수 있습니다:

```json
# 인덱싱 시 라우팅 값 지정
PUT /my_index/_doc/1?routing=user123
{
  "title": "Document title",
  "user_id": "user123"
}

# 검색 시 동일한 라우팅 값 사용
GET /my_index/_search?routing=user123
```

## 4. 매핑 및 데이터 모델링

### 4.1 필드 타입 최적화

적절한 필드 타입을 선택하여 성능과 저장 공간을 최적화합니다:

- **keyword vs text**: 전문 검색이 필요하면 text, 정확한 매칭/집계/정렬이 필요하면 keyword
- **숫자 타입 최소화**: 필요한 범위에 맞는 가장 작은 타입 사용 (long 대신 integer 등)
- **날짜 형식 표준화**: 명확한 날짜 형식 지정
- **중첩 구조 관리**: nested 필드는 성능 영향 고려

### 4.2 멀티 필드 활용

다양한 사용 사례를 지원하기 위해 동일한 데이터를 여러 방식으로 인덱싱:

```json
PUT /my_index
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "standard",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "english": {
            "type": "text",
            "analyzer": "english"
          }
        }
      }
    }
  }
}
```

### 4.3 비정규화와 중첩 관계

Elasticsearch는 관계형 DB와 달리 비정규화를 선호합니다:

- **객체 vs 중첩 타입**: 객체는 필드 간 독립성 없음, 중첩 타입은 완전한 객체 보존
- **상위/하위 관계**: 부모-자식 관계를 모델링하는 join 필드 (제한적으로 사용)
- **비정규화**: 자주 함께 쿼리되는 데이터는 동일한 문서에 저장

## 5. 인덱스 템플릿 및 별칭

### 5.1 인덱스 템플릿

템플릿을 사용하여 새 인덱스에 자동으로 설정 및 매핑 적용:

```json
PUT _index_template/logs_template
{
  "index_patterns": ["logs-*"],
  "template": {
    "settings": {
      "number_of_shards": 1,
      "number_of_replicas": 1
    },
    "mappings": {
      "properties": {
        "timestamp": { "type": "date" },
        "message": { "type": "text" },
        "level": { "type": "keyword" }
      }
    }
  }
}
```

### 5.2 인덱스 별칭

별칭을 사용하여 인덱스 스위칭, 멀티 인덱스 쿼리, 필터링된 뷰 생성:

```json
# 단일 인덱스에 별칭 추가
POST /_aliases
{
  "actions": [
    {
      "add": {
        "index": "logs-2023.04.01",
        "alias": "current_logs"
      }
    }
  ]
}

# 여러 인덱스에 별칭 추가
POST /_aliases
{
  "actions": [
    {
      "add": {
        "indices": ["logs-2023.04.01", "logs-2023.04.02"],
        "alias": "recent_logs"
      }
    }
  ]
}

# 필터링된 별칭 생성
POST /_aliases
{
  "actions": [
    {
      "add": {
        "index": "logs-*",
        "alias": "error_logs",
        "filter": {
          "term": {
            "level": "ERROR"
          }
        }
      }
    }
  ]
}
```

### 5.3 롤오버 및 별칭 스위칭

롤오버 API와 인덱스 별칭을 결합하여 인덱스 전환을 관리:

```json
# 초기 인덱스 생성 (별칭 포함)
PUT /logs-000001
{
  "aliases": {
    "logs_write": {}
  }
}

# 롤오버 조건 지정
POST /logs_write/_rollover
{
  "conditions": {
    "max_age": "7d",
    "max_docs": 1000000,
    "max_size": "5gb"
  }
}
```

## 6. 인덱스 설계 패턴

### 6.1 시계열 데이터 패턴

로그, 메트릭, 이벤트 데이터를 위한 설계:

- **시간 기반 인덱스 이름**: `logs-YYYY.MM.DD`
- **롤오버 정책**: 크기 또는 시간 기준
- **핫-웜-콜드 아키텍처**: 데이터 활용도에 따른 스토리지 티어
- **보존 정책**: 삭제 또는 스냅샷 자동화

### 6.2 멀티테넌트 패턴

여러 고객/조직의 데이터를 다루는 설계:

#### 인덱스 per 테넌트
- **장점**: 완벽한 격리, 개별 최적화
- **단점**: 샤드 오버헤드, 많은 인덱스 관리 복잡성

```
customer1_data
customer2_data
customer3_data
```

#### 타입/라우팅 기반 분할
- **장점**: 샤드 효율성, 관리 간소화
- **단점**: 완전한 격리 부족, 쿼리 복잡성

```json
# 인덱싱 시 테넌트 ID로 라우팅
PUT /shared_index/_doc/1?routing=tenant123
{
  "tenant_id": "tenant123",
  "title": "Document title"
}

# 쿼리 시 필터링 및 라우팅
GET /shared_index/_search?routing=tenant123
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "tenant_id": "tenant123" } }
      ]
    }
  }
}
```

### 6.3 검색 중심 패턴

검색 성능을 최적화하는 설계:

- **동의어 및 맞춤법 검사**: 분석기 및 토크나이저 최적화
- **관련성 튜닝**: 필드 가중치 및 부스팅
- **결과 캐싱**: 자주 사용되는 쿼리를 위한 요청 캐시 설정
- **검색 템플릿**: 사전 정의된 쿼리 템플릿 활용

### 6.4 집계 중심 패턴

분석 및 집계 성능을 최적화하는 설계:

- **롤업 인덱스**: 사전 계산된 집계 결과 저장
- **샘플링**: 대규모 데이터셋에서 근사 결과
- **필드 최적화**: doc_values 및 fielddata 설정 조정
- **사전 계산**: 자주 사용되는 집계 결과 사전 계산

## 7. 인덱스 유지 관리 및 최적화

### 7.1 세그먼트 관리

세그먼트를 병합하여 검색 성능 향상 및 디스크 공간 확보:

```json
# 강제 병합 수행
POST /my_index/_forcemerge
{
  "max_num_segments": 1
}
```

### 7.2 캐싱 전략

다양한 캐시 유형을 설정하여 성능 최적화:

```json
PUT /my_index
{
  "settings": {
    "index.queries.cache.enabled": true,
    "index.requests.cache.enable": true,
    "index.fielddata.cache.size": "10%"
  }
}
```

### 7.3 리인덱싱 및 마이그레이션

데이터를 새 인덱스로 이동하거나 매핑을 업데이트:

```json
POST /_reindex
{
  "source": {
    "index": "old_index"
  },
  "dest": {
    "index": "new_index"
  }
}
```

## 8. 실무 사례 연구

### 8.1 로깅 및 모니터링 시스템

로깅 시스템을 위한 인덱스 설계:

- **시간 기반 인덱스**: 일별 로그 인덱스
- **ILM 정책**: 핫-웜-콜드 아키텍처
- **필드 최적화**: 자주 검색/집계되는 필드에 최적화된 매핑
- **템플릿 및 별칭**: 로그 유형별 표준화된 템플릿

### 8.2 전자상거래 검색

전자상거래 플랫폼을 위한 인덱스 설계:

- **제품 인덱스**: 풍부한 텍스트 분석기, 동의어 사전
- **카테고리 최적화**: 계층적 구조를 위한 경로 매핑
- **재고 업데이트**: 부분 업데이트를 위한 효율적인 설계
- **사용자 행동**: 사용자 행동 데이터를 위한 별도 인덱스

### 8.3 콘텐츠 관리 시스템

CMS를 위한 인덱스 설계:

- **콘텐츠 타입 기반**: 글, 페이지, 미디어별 매핑
- **권한 모델**: 접근 제어를 위한 필드 설계
- **버전 관리**: 콘텐츠 버전 관리를 위한 전략
- **검색 최적화**: 여러 언어 지원을 위한 분석기 설정

## 결론

효과적인 Elasticsearch 인덱스 설계는 데이터 특성, 쿼리 패턴, 성능 요구사항을 균형 있게 고려해야 합니다. 시간 기반 인덱스, 적절한 샤딩 전략, 최적화된 매핑, 그리고 인덱스 템플릿과 별칭을 활용하여 확장 가능하고 관리하기 쉬운 인프라를 구축할 수 있습니다.

인덱스 설계는 한 번 결정되고 끝나는 것이 아니라, 데이터와 요구사항의 변화에 따라 지속적으로 발전해야 하는 과정입니다. 정기적인 모니터링과 최적화를 통해 Elasticsearch 클러스터의 성능과 효율성을 유지해야 합니다.